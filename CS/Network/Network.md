# Throttling
서버가 클라이언트로부터 오는 **요청의 속도를 제어**하는 기술입니다.

### Throttling을 사용하는 이유
 1. **서버 자원 보호**:<br>
쓰로틀링을 통해 서버 자원을 보호하고, 과도한 요청으로 인한 서버의 과부하를 방지할 수 있습니다. 이를 통해 서비스의 안정성과 가용성을 높일 수 있습니다.


2. **서비스 품질 관리**:<br>
쓰로틀링은 트래픽을 제어하여 모든 사용자에게 일관된 서비스 품질을 제공하는 데 도움이 됩니다. 특히 서비스가 폭발적인 인기를 끌 때 불규칙한 트래픽 흐름을 조절할 수 있습니다.


3. **비용 절감**:
쓰로틀링을 통해 서버 리소스를 효율적으로 사용하여 클라우드 서비스 비용을 절감할 수 있습니다. 이는 서버 크기를 줄이거나 예약 인스턴스를 활용하는 데 도움이 됩니다.


4. **보안 강화**:
쓰로틀링은 DDoS 공격과 같은 악의적인 트래픽을 방어하는데 도움이 됩니다. 정상적인 트래픽 패턴을 벗어난 요청을 제한함으로써 보안을 강화할 수 있습니다.

### Algorithm

#### Fixed Window
1. 특정 기간 동안의 고정된 시간 윈도우를 사용한다.
2. 각 시간 윈도우 내에서 수행한 요청 수를 추적한다.
3. 해당 시간 윈도우 내에서 요청 수가 허용된 제한을 초과하면 추가 요청은 지연되거나 거부된다.

특징:
1. 개별 요청의 시간을 고려하지 않습니다. 예를 들어 클라이언트가 윈도우 시작부터 많은 요청을 하면 긴 시간 동안 전체 윈도우 내에서 제한을 초과하여 쓰로틀링 될 수 있습니다.
2. 기간 경계의 편향된 요청에 의해 부하가 커질수 있다.
#### Sliding Window
1. 슬라이딩 시간 윈도우는 지속적으로 시간과 함께 이동하며, 어느 시점에서도 해당 시점 이전에 발생한 지정된 시간 윈도우 내의 요청 수를 추적한다.
2. 슬라이딩 시간 윈도우 내에서 허용된 제한을 초과하면 추가 요청은 지연되거나 거부한다.

rate 계산법:
1. 현재 시간이 윈도우의 몇퍼센트인지 파악. ex) 윈도우 사이즈(5초), 현재 2초 -> 2/5 * 100 = 40%
2. 이전 윈도우에 요청 횟수가 10번이였다고 가정하면 그 값의 60%되는 값을 구한다, 10번 * .6 = 6
3. 현재 윈도우에 요청이 4번 들어왔다고 가정한다면 최종 계산 값은 6 + 4 = 10
4. 계산된 10의 값이 rate를 초과하였으면 요청 거부

특징: Fixed Window의 단점(bursty traffic)에 대해 극복 가능하지만, 시간 윈도우 내에서 타임스탬프 및 각각의 개별 요청에 대한 요청 횟수를 추적할 필요가 있기 때문에 메모리 비용이 높다. 시간 윈도우가 작아질수록 메모리 오버헤드는, 특히 트래픽이 많은 시나리오에서 크게 증가할 수 있습니다.

#### Leaky Bucket
1. 버킷은 고정된 용량을 가지고 있다.
2. 일정한 간격으로 버킷은 고정된 수의 요청 또는 토큰을 제거하여 용량을 지속적으로 회수합니다. 이를 통해 새로운 요청을 처리할 수 있는 용량이 지속적으로 확보됩니다.
3. 만약 버킷이 들어오는 요청을 처리하는데 충분한 용량을 가지고 있다면, 요청은 허용된다. 버킷이 가득 차 있으면 요청은 지연되거나 거부된다.

특징: 일정한 속도로 처리하기때문에 bursty 요청은 처리 불가능
#### Token Bucket
1. 토큰 버킷은 고정된 용량을 가지고 있다.
2. 정해진 rate에 맞추어 토큰을 채운다.
3. 토큰 버킷이 요청을 처리하기에 충분한 토큰을 가지고 있다면, 요청은 허용되고, 비어있다면 요청은 지연되거나 거부된다.

특징: bursty 요청에 대해 어느수준 처리가 가능