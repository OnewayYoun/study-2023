# 컴퓨터 네트워크 인터뷰

<br/>

### 쿠키와 세션의 차이는?
A: 쿠키와 세션의 차이는 사용자 정보를 저장하는 장소에 차이가 있습니다. 쿠키는 사용자 정보를 클라이언트에 저장하고, 세션은 서버에 저장합니다.

### 세션 방식의 로그인 과정
A:
1. 클라이언트는 사용자의 credential과 함께, 서버에 로그인 요청을 합니다.
2. 서버는 사용자에 대한 로그인 인증을 진행하고, 인증이 정상적으로 됐다면 세션 객체를 생성하고 세션 id를 set-cookie를 통해 클라이언트에게 전달합니다.
3. 세션 객체를 서버에 저장합니다.
4. 클라이언트가 서버에 작업 요청을 할 때 마다, 요청헤더에 세션 id가 같이 전달됩니다.
5. 클라이언트로부터 받은 요청헤더의 세션 id를 확인해서, 세션 객체를 검색하고 정보가 있으면, 요청에 대해 응답하고, 통신을 종료합니다.

### 세션 방식의 장단점?
A: 세션 방식의 장점은 세션 id를 주고 받기 때문에, 중간에 탈취 되더라도 세션 id 자체만으로는 사용자의 정보를 알 수 없는 장점이 있습니다.<br/>
하지만 세션 방식의 단점은 하이재킹이 가능하다는 것인데, 여기서 하이재킹은 공격자가 중간에 세션을 가로채고 이 세션을 통해 서버에 요청을 보내 응답을 받는 것을 의미합니다.<br/
또 다른 단점으로 세션을 유지해야하기 때문에, 사용자가 많으면 많을 수록 부하가 생깁니다.

### HTTP의 stateless?
A: HTTP의 stateless는 클라이언트의 세션 상태 또는 세션 정보를 저장하지 않는 것을 의미합니다. 각 요청은 독립적이며, 이전의 통신 또는 세션 정보에 의존하지 않습니다.<br/>
statless의 장점으로 확장성이 좋습니다. 상태를 저장하지 않기 때문에, 서버를 쉽게 추가 또는 제거 할 수 있습니다. 단점으로는 상태가 없기 때문에, 한 번의 요청에 많은 양의 데이터가 전송 될 수 있는 상황이 발생 할 수 있습니다.

### 규모가 커져서, 서버가 여러개 된다면, 세션을 어떻게 관리 할 수 있을까요?
A: 규모가 커져서, 다수의 서버를 둘 때, 세션 관리를 위해 세션 관리를 위한 전용 서버를 둘 수 있습니다. 따라서 다른 나머지 서버는 세션 관리 전용 서버를 통해, 세션을 확인 할 수 있습니다.

### 401과 403의 차이?
A: 401은 클라이언트가 인증되지 않았거나, 유효한 인증 정보가 부족하여 요청이 거부됐을 때를 의미하는 http status 값입니다.<br/>
403은 클라이언트가 해당 요청에 대해 권한이 없다는 것을 의미합니다.

### 200과 201의 차이?
A: 200은 클라이언트의 요청이 서버에서 정상 처리되어, 201은 서버가 요청의 결과로 새로운 자원을 성공적으로 생성했음을 의미합니다.

### HTTP method의 멱등성에 대해 설명해주세요.
A: HTTP method에서 멱등성이란, 요청을 한 번 호출하든, 여러번 호출하든, 결과는 항상 동일해야합니다. 멱등성을 확인하고 싶다면, 서버의 상태를 확인하면 됩니다.
<br/> 만약, method별로 멱등성을 확인하고 싶다면
- GET : 서버에 존재하는 리소스를 단순히 읽기만 하므로, 동일한 요청을 여러번 수행할 때마다, 동일한 결과를 받습니다.
- PUT : 서버에 존재하는 리소스를 완전히 대체하므로, 동일한 요청을 여러번 수행할 때마다, 동일한 결과를 받습니다.
- DELETE : 동일한 요청을 여러번 할 때, 처음 요청에 대한 결과의 메세지와 그 이후 요청에 대한 결과의 메세지는 다르겠지만, 서버의 상태는 동일하기 때문에 멱등성을 갖습니다.
- POST : 멱등성을 갖지 않을 수 있습니다. 예를들어, 하나의 동일한 데이터를 저장을 위한 요청을 여러번 할 때 마다, 서버는 같은 데이터를 계속해서 추가해서 저장 할 수 있습니다.
- PATCH : 멱등성을 갖지 않을 수 있습니다. 예를들어, 한 속성의 타입이 integer일 경우, 이 속성에 대해 증감 연산자를 적용하면 해당 속성은 동일한 요청을 반복 할 때마다, 계속해서 증가 또는 감소 할 수 있습니다. 따라서 서버의 상태가 동일하지 않습니다.

### GET과 POST의 차이?
GET은 서버로부터 데이터를 조회 할 때 사용하고, POST는 데이터를 서버에 추가하거나 서버의 상태를 변경 할 때 사용됩니다.

### POST, PUT, PATCH의 차이점?
POST는 새로운 데이터를 서버에 추가 할 때 사용하고, PUT은 기존의 리소스를 새로운 리소스로 완전히 대체 할 떄 사용하고, PATCH는 기존 리소스의 일부 속성을 변경 할 때 사용합니다.

### 공개키, 대칭키의 차이점?
공개키(비대칭키) 암호화를 위해 사용되는 키와 복호화를 위해 사용되는 키가 다르고, 대칭키는 암호화에 사용되는 키와 복호화에 사용되는 키가 동일하다는 차이가 있습니다.

### SSL handshake에서 인증서를 사용하는 이유?
A: 서버와 클라이언트 사이에서 안전하고 암호화된 통신을 위해 사용됩니다. 구체적으로 인증, 암호화, 데이터 통합, 신뢰성을 위해 사용되는데
- 인증서를 통해, 웹사이트의 신원을 확인 할 수 있습니다. 인증서를 확인함으로써, 올바른 웹사이트로 연결되며 위조나 악성서버가 아닌지 확인합니다.
- 인증서를 통해, 암호화된 연결을 설정 할 수 있습니다.
- 인증서를 통해, 데이터 무결성을 보장 할 수 있습니다. 해시 함수와 디지털 서명을 통해, 전송 중인 데이터가 변경되지 않았음을 확인 할 수 있습니다.
- 인증서를 통해, 신뢰성을 보장 할 수 있습니다. 웹 브라우저의 경우, 인증서를 발급하는 CA 목록을 갖고 있습니다. 서버가 CA에 의해 서명된 디지털 인증서를 브라우저에게 제시하면, 브라우저는 서버에 대한 웹페이지가 진짜임을 확인 할 수 있습니다.

### SSL과 TLS의 차이
A: SSL은 주로 RC4를 사용하고, TLS는 AES 알고리즘을 사용합니다.

### HTTP?
A: HTTP는 OSI7 layer의 application layer에 속하는 프로토콜로, html 문서와 같은 리소스를 가져 올 수 있는 프로토콜입니다.

### HTTP/1.1과 HTTP/2 차이
A: HTTP1.0은 기본적으로 connection 당 하나의 요청을 처리 할 수 있으며, 동시 전송이 불가능하기 때문에 요청과 응답이 순차적으로 이루어집니다. 따라서 하나의 요청에 대한 응답을 받기 전에, 다른 요청을 보낼 수 없습니다. 이로 인해 브라우저와 서버간의 지연이 발생 할 수 있습니다.<br/>
HTTP2는 하나의 connection에서 다수의 메세지를 주고 받을 수 있으며, 응답은 순서에 상관 없이, stream으로 받습니다.<br/>
헤더 압축에도 차이가 있는데, HTTP1.1은 요청과 응답마다 중복되는 헤더 정보를 전송해야하지만, HTTP2의 경우, 헤더 압축을 통해 중복되는 헤더를 압축 할 수 있습니다.<br/>
HTTP1.1은 서버 푸시를 지원하지 않지만 HTTP2.0은 지원합니다. 따라서, HTTP2를 사용하면 클라이언트가 서버에게 리소스를 요청하지 않아도, 서버는 클라이언트에게 리소스를 전달 할 수 있습니다.<br/>
프레임 구조에도 차이가 존재하는데, HTTP1.1은 텍스트 기반의 프로토콜이며, HTTP2는 이진 프레임 구조를 사용하여 데이터를 사용합니다.

### 3-way handshake
A: 3-way handshake는 데이터를 전송하기 전에, 정확한 데이터 전송을 보장하기 위해, 상대방의 장치와 사전에 세션을  정확한 데이터 전송을 보장하기 위해, 상대방의 장치와 사전에 연결을 수립하는 과정수입하는 과정을 의미합니다.<br/>
이를 위환 과정으로
1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 전송합니다.
2. 서버는 클라이언트로부터 받은 SYN 패킷에 대한 응답으로 ACK 패킷 그리고 SYN 패킷을 클라이언트에게 전달합니다.
3. 클라이언트는 서버로 부터 받은 SYN 패킷에 대한 응답으로 ACK 패킷을 서버에게 전달합니다.
위의 과정을 전부 거치면, 연결이 수립됩니다.

### 4-way handshake
A: 4-way handshake는 연결을 종료하기 위해, 수행하는 절차이며 과정은
1. 클라이언트가 서버에게 FIN 플래그가 담긴 패킷을 서버에게 전송합니다. 
2. 서버는 FIN 패킷에 대한 응답으로 ACK를 보냅니다.
3. 서버가 통신이 끝났으면, 서버는 연결이 종료됐다고, 클라이언트에게 FIN 플래그가 담긴 패킷을 전송합니다.
4. 클라이언트는 서버로부터 받은 FIN 패킷을 확인했다는 응답을 전송합니다.

### 네이버를 입력했을 때, 어떤 일이 발생하는가?
A: 가장 먼저 사용자가 입력한 도메인 이름에 대한 IP주소를 알야아합니다. 이를 DNS resolution이라고 하는데, 브라우저는 DNS 서버에 요청하여 도메인 네임에 대한 IP주소를 알아냅니다.<br/>
클라이언트가 사용하는 DNS 서버 정보를 알고 싶다면, 운영체제의 네트워크 설정을 확인하시면 됩니다.<br/>
DNS 서버로부터 IP주소를 획득했다면, 클라이언트는 이를 이용하여 해당 웹 사이트를 갖는 서버와의 연결을 시도합니다. 만약 HTTP를 사용한다면 포트번호 80번, HTTPS를 사용한다면 포트번호 443번을 사용하게 됩니다.<br/>
만약 HTTPS를 사용하게 된다면 SSL 핸드셰이크를 진행하고 이를 통해, 암호화된 데이터 전송을 할 수 있게 됩니다.<br/>
연결이 정상적으로 수립됐다면, 브라우저는 HTTP METHOD를 통해, HTML문서, js, css등 리소스들을 서버에게 요청하고, 서버로부터 리소스를 정상적으로 받았다면 렌더링을 시작합니다. 이후 추가적인 리소스를 로드하기 위해 현서버 또는 다른 서버에 요청하고, 관련 리소스를 받아옵니다.<br/>
완전히 리소스를 받았다면, 이후 웹페이지에 대한 리소스를 완전히 로드하고 렌더링된다면 브라우저는 연결을 종료합니다.<br/>

### DNS recursive query?
A: host가 naver.com에 대한 query를 보내면, local dns서버가 root name server에게 query를 보내고, root server는 자신의 server에 관련 정보가 있는지 확인하고 없다면, com 담당 서버에게 요청합니다.<br/>
com 담당 서버에도 존재하지 않으면, 다음 하위 서버에 요청하는 recursion 방식으로 진행하게 되는데, 문제는 그동안 root server가 대기하고 있기 때문에 root server에 부담을 주는 문제가 있습니다.

### DNS iterative query?
A: host가 naver.com에 대한 query를 보내면, local dns서버가 root name server에 query를 보내고 이를 통해 com담당 서버 정보를 획득합니다. 이를 알아낸 local name server는 com담당 서버에게 query를 보내 naver.com에 대한 IP주소를 획득합니다.<br/>
이와같이, 도메인 네임에 대한 IP주소를 찾을 때까지, local name server가 반복적으로 name서버에 요창하는 과정을 DNS iterative query라고 합니다.

### DNS 레코드 타입
A
- SOA : 도메인의 시작점이며 도메인에 대한 선언을 시작하는 부분입니다. 도메인 네임 서버, 관리자 메일을 지정 할 수 있습니다. SOA가 존재하지 않으면, 다른 레코드는 등록 할 수 없습니다.
- A : 정규화된 도메인 이름, 호스트명(FQDN)을 IPv4에 연결합니다.
- CNAME : 실제 호스트명과 연결되는 alias 즉, 별칭을 정의해주는 레코드입니다.

### HTTPS 동작 원리






