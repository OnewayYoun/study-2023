# Throttling
서버가 클라이언트로부터 오는 **요청의 속도를 제어**하는 기술입니다.

### Throttling을 사용하는 이유
 1. **서버 자원 보호**:<br>
쓰로틀링을 통해 서버 자원을 보호하고, 과도한 요청으로 인한 서버의 과부하를 방지할 수 있습니다. 이를 통해 서비스의 안정성과 가용성을 높일 수 있습니다.


2. **서비스 품질 관리**:<br>
쓰로틀링은 트래픽을 제어하여 모든 사용자에게 일관된 서비스 품질을 제공하는 데 도움이 됩니다. 특히 서비스가 폭발적인 인기를 끌 때 불규칙한 트래픽 흐름을 조절할 수 있습니다.


3. **비용 절감**:
쓰로틀링을 통해 서버 리소스를 효율적으로 사용하여 클라우드 서비스 비용을 절감할 수 있습니다. 이는 서버 크기를 줄이거나 예약 인스턴스를 활용하는 데 도움이 됩니다.


4. **보안 강화**:
쓰로틀링은 DDoS 공격과 같은 악의적인 트래픽을 방어하는데 도움이 됩니다. 정상적인 트래픽 패턴을 벗어난 요청을 제한함으로써 보안을 강화할 수 있습니다.

### Algorithm

#### Fixed Window
1. 특정 기간 동안의 고정된 시간 윈도우를 사용한다.
2. 각 시간 윈도우 내에서 수행한 요청 수를 추적한다.
3. 해당 시간 윈도우 내에서 요청 수가 허용된 제한을 초과하면 추가 요청은 지연되거나 거부된다.

특징:
1. 개별 요청의 시간을 고려하지 않습니다. 예를 들어 클라이언트가 윈도우 시작부터 많은 요청을 하면 긴 시간 동안 전체 윈도우 내에서 제한을 초과하여 쓰로틀링 될 수 있습니다.
2. 기간 경계의 편향된 요청에 의해 부하가 커질수 있다.
#### Sliding Window
1. 슬라이딩 시간 윈도우는 지속적으로 시간과 함께 이동하며, 어느 시점에서도 해당 시점 이전에 발생한 지정된 시간 윈도우 내의 요청 수를 추적한다.
2. 슬라이딩 시간 윈도우 내에서 허용된 제한을 초과하면 추가 요청은 지연되거나 거부한다.

rate 계산법:
1. 현재 시간이 윈도우의 몇퍼센트인지 파악. ex) 윈도우 사이즈(5초), 현재 2초 -> 2/5 * 100 = 40%
2. 이전 윈도우에 요청 횟수가 10번이였다고 가정하면 그 값의 60%되는 값을 구한다, 10번 * .6 = 6
3. 현재 윈도우에 요청이 4번 들어왔다고 가정한다면 최종 계산 값은 6 + 4 = 10
4. 계산된 10의 값이 rate를 초과하였으면 요청 거부

특징: Fixed Window의 단점(bursty traffic)에 대해 극복 가능하지만, 시간 윈도우 내에서 타임스탬프 및 각각의 개별 요청에 대한 요청 횟수를 추적할 필요가 있기 때문에 메모리 비용이 높다. 시간 윈도우가 작아질수록 메모리 오버헤드는, 특히 트래픽이 많은 시나리오에서 크게 증가할 수 있습니다.

#### Leaky Bucket
1. 버킷은 고정된 용량을 가지고 있다.
2. 일정한 간격으로 버킷은 고정된 수의 요청 또는 토큰을 제거하여 용량을 지속적으로 회수합니다. 이를 통해 새로운 요청을 처리할 수 있는 용량이 지속적으로 확보됩니다.
3. 만약 버킷이 들어오는 요청을 처리하는데 충분한 용량을 가지고 있다면, 요청은 허용된다. 버킷이 가득 차 있으면 요청은 지연되거나 거부된다.

특징: 일정한 속도로 처리하기때문에 bursty 요청은 처리 불가능
#### Token Bucket
1. 토큰 버킷은 고정된 용량을 가지고 있다.
2. 정해진 rate에 맞추어 토큰을 채운다.
3. 토큰 버킷이 요청을 처리하기에 충분한 토큰을 가지고 있다면, 요청은 허용되고, 비어있다면 요청은 지연되거나 거부된다.

특징: bursty 요청에 대해 어느수준 처리가 가능

---

# L4 전송 계층

## TCP vs UDP

**TCP**
1. **연결지향** 프로토콜을 사용하여 **신뢰성**을 구축(3,4-way handshake로 연결성 보장, 해제함)
2. 패킷 사이의 **순서를 보장**함
3. "가상회선 패킷 교환 방식"을 사용함
4. 1:1 통신
~~~
가상회선 패킷 교환 방식은 각 패킷에는 가상회선 식별자가 포함되며 모든 패킷을 전송하면
가상회선이 해제되고 패킷들은 전송된 순서대로 도착하는 방식을 말한다.
위와 같은 이유로 신뢰성(흐름 제어, 혼잡 제어, 오류 제어)을 보장해주고 신뢰성 보장 절차가
없는 UDP에 비해서는 속도가 느리다.
~~~
**UDP**
1. **비연결형** 서비스로 "데이터그램 패킷 교환 방식"을 제공한다
~~~
패킷이 독립적으로 이동하며 최적의 경로를 선택하여 가는데, 하나의 메시지에서 분할된 여러 패킷은
서로 다른 경로로 전송될 수 있으며 도착한 '순서가 다를 수'있다.
~~~
2. 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.(빠르다)
3. UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
4. 신뢰성이 낮다
5. TCP보다 속도가 빠르다
6. 1:1 or 1:N or N:N 통신


## 3 Way Handshake & 4 Way Handshake

**3 Way Handshake**
1. SYN 단계: 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보낸다.
2. SYN + ACK 단계: 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보낸다.
3. ACK 단계: 클라이언트는 서버의 ISN+1한 값인 승인번호를 담아 ACK를 서버에 보낸다.

~~~
ISN(Initial Sequence Numbers): 새로운 TCP 연결의 첫 번쨰 패킷에 할당된 임의의 시퀀스 번호를 말한다.
SYN(Synchronization): 연결 요청 플래그
ACK(Acknowledgement): 응답 플래그
~~~

**4 Way Handshake**
1. 클라이언트가 연결을 닫으려고 할때 FIN으로 설정된 세그먼트를 보낸다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다린다.
2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보낸다. 그리고 CLOSE_WAIT 상태에 들어간다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어간다.
3. 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보낸다.
4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 된다. 이후 클라이언트는 어느 정도의 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제된다.

~~~
TIME_WAIT
소켈이 바로 소멸되지 않고 일정 시간 유지되는 이유:
1. 지연 패킷이 발생할 경우를 대비하기 위함
2. 두 장치가 연결이 닫혔는지 확인하기 위함.
  - 만약 LAST_ACK 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할 때 장치는 줄 곧
    LAST_ACK로 되어 있어 접속 오휴가 나타날수 있다.
~~~