# 트랜잭션과 무결성

## 트랜잭션, ACID

트랜잭션은 논리적인 작업 단위이다. 따라서 읽기 연산, 쓰기 연산을 트랜잭션을 통해, 하나의 작업 단위로 취급 할 수 있습니다.<br/>
트랜잭션을 진행하면서, 데이터의 무결성을 지키기 위해서는 ACID 원칙을 지켜야합니다.<br/>
- A(Atomicity) : 원자성을 의미하며, 트랜잭션의 결과는 성공 또는 실패입니다. 트랜잭션 내의 일부 연산은 성공하고, 일부 연산은 실패하는 것을 허용하지 않습니다.
- C(Consistency) : 일관성을 의미하며, 트랜잭션이 데이터베이스의 상태를 변경해도, 그 상태는 일관 되어야합니다.
- I(Isolation) : 격리성을 의미하며, 트랜잭션들은 서로 독립적이여야 하며, 다른 트랜잭션에 영향을 주어서는 안됩니다.
- D(Durability) : 지속성을 의미하며, 트랜잭션에 의햔 변경사항은 영구적으로 데이터베이스에 반영되어야합니다.

<br/>

## DBMS는 어떻게 지속성을 보장하는가

DBMS는 지속성을 보장하기 위해, 트랜잭션 커밋을 사용합니다. 여기서 트랜잭션 커밋은 트랜잭션이 성공적으로 완료됐음을 의미합니다.<br/> 
트랜잭션의 경우, 트랜잭션이 완료되기 전까지, 각 연산의 결과는 메모리에 일시적으로 저장되어있다가, 모든 연산들이 성공됐을 떄, 해당 트랜잭션을 커밋하여 트랜잭션의 결과를 데이터베이스의 실제 파일에 영구적으로 반영합니다.<br/>

<br/>

## 읽기 연산에는 트랜잭션을 걸어야 하는가

읽기 연산에도 트랜잭션을 걸어야하는 경우가 있습니다. 예를들어, 사용자가 동시에 데이터베이스에 접근하는 경우, 트랜잭션 격리를 유지해야합니다.<br/>
트랜잭션 시작과 끝 사이에 읽기 연산이 존재할 때, 중간에 존재하는 읽기 연산은 시작 시점의 연산에 영향을 받아야지, 다른 트랜잭션에 영향을 받으면 안됩니다.<br/>
또 다른 예로, 트랜잭션 내에서 읽기 연산을 여러번 할 때, 트랜잭션 내 데이터들은 동일한 시점에 동일한 데이터를 제공해야합니다. 만약 다른 트랜잭션이 해당 데이터에 영향을 준다면, 읽기에 대한 일관성이 깨질 수 있습니다.<br/>
마지막 예로, 데이터 정합성을 확인하기 위해, 읽기 연산을 트랜잭션에 포함 할 수 있습니다. 즉, 읽기 연산을 트랜잭션에 포함시킴으로써, 중간에 값을 읽어서 조건에 따라 트랜잭션을 계속 진행하거나 중단 할 수 있습니다.<br/>

## 트랜잭션 격리 레벨

트랜잭션 격리 레벨이란, 여러 트랜잭션이 동시 처리 될 때, 특정 트랜잭션이 다른 트랜잭션에 어느정도까지 영향을 미칠 것인지의 정도를 결정하는 것입니다.<br/>
낮은 단계부터 언급하면, READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALZABLE이 있습니다.
- READ UNCOMMITED : 다른 트랜잭션이 커밋하지 않는 데이터 또는 롤백 되지 않는 데이터를 볼 수 있습니다. 여기서 Dirty read가 발생 할 수 있는데, 한 트랜잭션에서 동일한 데이터에 대한 읽기 연산을 했음에도 읽기 결과가 달라질 수 이습니다.<br/>
- READ COMMITED : 커밋된 데이터만 조회 할 수 있습니다. 여기서 발생 할 수 있는 문제로, repeatable read, phantom read가 존재합니다. 
  - repeatable read : 한 트랜잭션 내에서 반복 읽기를 수행하면, 트랜잭션의 커밋의 순서에 따라 결과가 달라질 수 있습니다.
    - 2개의 트랜잭션이 존재 할 때, 동일한 데이터에 대해, 시점1에서 트랜잭션 1은 데이터를 read하고 시점 2에서 트랜잭션 2가 데이터를 write 후 커밋됐을 때, 시점 3에서 트랜잭션 1은 데이터를 read할 때 트랜잭션 2에 의해 변경된 데이터를 읽습니다.
- REPEATABLE READ : 트랜잭션 내 같은 쿼리를 반복 수행해도, 결과가 동일하는 것을 보장합니다. 하지만 새로운 레코드가 다른 트랜잭션에 의해 생성되는 경우, 부정합이 발생 할 수 있습니다.(phantom read)
  - phantom read의 예로, 시점1에서 다른 트랜잭션이 데이터를 추가하고 데이터가 시점2에서 또 다른 트랜잭션의 데이터 read시 추가된 데이터도 읽는 현상이 있습니다.
- SERIALIZABLE : 여러 트랜잭션이 동일한 레코드에 접근 할 수 없습니다. 따라서 데이터 부정합 문제는 발생하지 않지만, 트랜잭션이 순차적으로 수행되어야 하기 떄문에, 동시 처리 성능이 떨어집니다.

<br/>


## 모든 DBMS가 모든 격리레벨을 구현하고 있는가

4개의 레벨을 모두 구현하지는 않습니다. 왜냐하면 트랜잭션의 격리 레벨을 높이면, 동시 처리 성능이 떨어지고, 격리 수준을 너무 낮추면 일관성이 떨어지기 때문에, 4개의 레벨을 모두 구현하지 않습니다.

<br/>

## innoDB기반 MySQL을 사용할 때, undo영역과 redo영역은 무엇인가

undo 영역은 데이터가 변경되기 이전의 데이터를 보관하는 곳입니다. 트랜잭션 롤백의 대비용으로 사용됩니다.
- 높은 격리성, 높은 동시성

<br/>

redo 영역은 트랜잭션을 처리하는 과정에서 변경된 데이터를 기록하는 용도로 사용됩니다. 트랜잭션 변경사항이 redo 영역에 기록되면, 해당 변경사항은 디스크에 반영되기 전까지 보관됩니다.