# 트랜잭션과 무결성

## 트랜잭션, ACID

트랜잭션은 논리적인 작업 단위이다. 따라서 읽기 연산, 쓰기 연산을 트랜잭션을 통해, 하나의 작업 단위로 취급 할 수 있습니다.<br/>
트랜잭션을 진행하면서, 데이터의 무결성을 지키기 위해서는 ACID 원칙을 지켜야합니다.<br/>
- A(Atomicity) : 원자성을 의미하며, 트랜잭션의 결과는 성공 또는 실패입니다. 트랜잭션 내의 일부 연산은 성공하고, 일부 연산은 실패하는 것을 허용하지 않습니다.
- C(Consistency) : 일관성을 의미하며, 트랜잭션이 데이터베이스의 상태를 변경해도, 그 상태는 일관 되어야합니다.
- I(Isolation) : 격리성을 의미하며, 트랜잭션들은 서로 독립적이여야 하며, 다른 트랜잭션에 영향을 주어서는 안됩니다.
- D(Durability) : 지속성을 의미하며, 트랜잭션에 의햔 변경사항은 영구적으로 데이터베이스에 반영되어야합니다.

<br/>

## DBMS는 어떻게 지속성을 보장하는가

DBMS는 지속성을 보장하기 위해, 트랜잭션 커밋을 사용합니다. 여기서 트랜잭션 커밋은 트랜잭션이 성공적으로 완료됐음을 의미합니다.<br/> 
트랜잭션의 경우, 트랜잭션이 완료되기 전까지, 각 연산의 결과는 메모리에 일시적으로 저장되어있다가, 모든 연산들이 성공됐을 떄, 해당 트랜잭션을 커밋하여 트랜잭션의 결과를 데이터베이스의 실제 파일에 영구적으로 반영합니다.<br/>

<br/>

## 읽기 연산에는 트랜잭션을 걸어야 하는가

읽기 연산에도 트랜잭션을 걸어야하는 경우가 있습니다. 예를들어, 사용자가 동시에 데이터베이스에 접근하는 경우, 트랜잭션 격리를 유지해야합니다.<br/>
트랜잭션 시작과 끝 사이에 읽기 연산이 존재할 때, 중간에 존재하는 읽기 연산은 시작 시점의 연산에 영향을 받아야지, 다른 트랜잭션에 영향을 받으면 안됩니다.<br/>
또 다른 예로, 트랜잭션 내에서 읽기 연산을 여러번 할 때, 트랜잭션 내 데이터들은 동일한 시점에 동일한 데이터를 제공해야합니다. 만약 다른 트랜잭션이 해당 데이터에 영향을 준다면, 읽기에 대한 일관성이 깨질 수 있습니다.<br/>
마지막 예로, 데이터 정합성을 확인하기 위해, 읽기 연산을 트랜잭션에 포함 할 수 있습니다. 즉, 읽기 연산을 트랜잭션에 포함시킴으로써, 중간에 값을 읽어서 조건에 따라 트랜잭션을 계속 진행하거나 중단 할 수 있습니다.<br/>

<br/>

## 트랜잭션 격리 레벨

트랜잭션 격리 레벨이란, 여러 트랜잭션이 동시 처리 될 때, 특정 트랜잭션이 다른 트랜잭션에 어느정도까지 영향을 미칠 것인지의 정도를 결정하는 것입니다.<br/>
낮은 단계부터 언급하면, READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALZABLE이 있습니다.
- READ UNCOMMITED : 다른 트랜잭션이 커밋하지 않는 데이터 또는 롤백 되지 않는 데이터를 볼 수 있습니다. 여기서 Dirty read가 발생 할 수 있는데, 한 트랜잭션에서 동일한 데이터에 대한 읽기 연산을 했음에도 읽기 결과가 달라질 수 이습니다.<br/>
- READ COMMITED : 커밋된 데이터만 조회 할 수 있습니다. 여기서 발생 할 수 있는 문제로, repeatable read, phantom read가 존재합니다. 
  - repeatable read : 한 트랜잭션 내에서 반복 읽기를 수행하면, 트랜잭션의 커밋의 순서에 따라 결과가 달라질 수 있습니다.
    - 2개의 트랜잭션이 존재 할 때, 동일한 데이터에 대해, 시점1에서 트랜잭션 1은 데이터를 read하고 시점 2에서 트랜잭션 2가 데이터를 write 후 커밋됐을 때, 시점 3에서 트랜잭션 1은 데이터를 read할 때 트랜잭션 2에 의해 변경된 데이터를 읽습니다.
- REPEATABLE READ : 트랜잭션 내 같은 쿼리를 반복 수행해도, 결과가 동일하는 것을 보장합니다. 하지만 새로운 레코드가 다른 트랜잭션에 의해 생성되는 경우, 부정합이 발생 할 수 있습니다.(phantom read)
  - phantom read의 예로, 시점1에서 다른 트랜잭션이 데이터를 추가하고 데이터가 시점2에서 또 다른 트랜잭션의 데이터 read시 추가된 데이터도 읽는 현상이 있습니다.
- SERIALIZABLE : 여러 트랜잭션이 동일한 레코드에 접근 할 수 없습니다. 따라서 데이터 부정합 문제는 발생하지 않지만, 트랜잭션이 순차적으로 수행되어야 하기 떄문에, 동시 처리 성능이 떨어집니다.

<br/>


## 모든 DBMS가 모든 격리레벨을 구현하고 있는가

4개의 레벨을 모두 구현하지는 않습니다. 왜냐하면 트랜잭션의 격리 레벨을 높이면, 동시 처리 성능이 떨어지고, 격리 수준을 너무 낮추면 일관성이 떨어지기 때문에, 4개의 레벨을 모두 구현하지 않습니다.

<br/>

## innoDB기반 MySQL을 사용할 때, undo영역과 redo영역은 무엇인가

undo 영역은 데이터가 변경되기 이전의 데이터를 보관하는 곳입니다. 트랜잭션 롤백의 대비용으로 사용됩니다.
- 높은 격리성, 높은 동시성

<br/>

redo 영역은 트랜잭션을 처리하는 과정에서 변경된 데이터를 기록하는 용도로 사용됩니다. 트랜잭션 변경사항이 redo 영역에 기록되면, 해당 변경사항은 디스크에 반영되기 전까지 보관됩니다. <br/>

## DB lock?

DB에서 lock이란, 여러 사용자들이 동시에 같은 데이터를 접근하는 상황에서, 데이터의 무결성과 일관성을 지키기 위해 사용됩니다.<br/>
- 공유 lock : 공유 lock이 걸리면, 읽기 연산만 가능하며 쓰기 연산은 허용하지 않습니다. 여러 트랜잭션이 동일한 레코드에 락을 걸 수 있습니다.
- 베타 lock : 공유 lock과 비슷하지만, lock이 걸린 상태에서, 다른 트랜잭션이 lock을 생성하는 것을 허용하지 않습니다. 
  - 다른 트랜잭션의 접근을 막음 -> write 연산을 위해 사용 될 수 있습니다. 뮤텍스와 비슷하다고 볼 수 있습니다.
- 업데이트 lock : 데이터 변경을 위해, 베타 lock을 걸기 전, 데드락을 방지 하기 위해, 사용되는 lock입니다.
  - 데드락 : 한 트랜잭션이 자원을 점유하는 상태에서 다른 트랜잭션이 갖고 있는 자원을 요구하고 동시에 반대로 다른 트랜잭션이 한 트랜잭션이 갖고 있는 자원을 요구 할 때 무한 대기에 걸리는 현상을 의미합니다.
- 인터널 lock : 사용자가 요청한 범위에 lock을 걸 수 있는지 확인하기 위해, 사용되는 lock입니다.

<br/>

## 낙관적 lock(Optimistic lock)
낙관적 lock은 데이터 변경 후, 저장하는 시점에 해당 데이터가 사용자에 의해 변경되지 않았는지 검사합니다. 이를 위한 방법으로 레코드를 붙이거나, 타임스탬프 같은 메타 데이터를 사용합니다.
<br/>
이를 위한 알고리즘으로 2명의 사용자가 존재한다고 할 때
1. 사용자 A가 데이터를 읽습니다.
2. 사용자 A가 데이터를 수정하는 동안, 사용자 B도 동일한 데이터를 읽습니다.
3. 사용자 A가 데이터를 저장 할 때, 낙관적 lock은 사용자 A가 읽어온 데이터 버전 번호 또는 타임스탬프와 같은 현재 데이터베이스에 저장된 버전 번호 또는 타임스탬프를 비교합니다.
4. 버전 번호 또는 타임스탬프가 동일하면, 데이터 저장이 성공적으로 이루어집니다.
5. 4번과 반대로 불일치하면, 데이터 충돌이 발생했다는 것을 의미하기 때문에, 이를 위한 처리가 필요합니다.

<br/>

## 비관적 lock(pessimistic lock)
비관적 lock은 자원 요청에 따른 동시성 문제가 발생할 것이라고 미리 예상하여, lock을 겁니다.

